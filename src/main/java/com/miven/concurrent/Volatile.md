# volatile

## 内存模型
> CPU 执行速度快于内存读取速度，因此 CPU 里面会有高速缓存
### 缓存一致性的解决方案
- 通过在总线加 lock 的方式
- 通过缓存一致性协议
```
    缓存一致性协议最出名的就是 Intel 的 MESI 协议，MESI 协议保证了每个缓存中使用的共享变量的副本是一致的。
它核心的思想是：当 CPU 写数据时，如果发现操作的变量是共享变量，即在其他 CPU 中也存在该变量的副本，会发出信
号通知其他 CPU 将该变量的缓存行置为无效状态，因此当其他 CPU 需要读取这个变量时，发现自己缓存中缓存该变量的
缓存行是无效的，那么它就会从内存重新读取。
```

## 并发编程中的三个概念
- 原子性
```
即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。
```
- 可见性
```
当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值。
```
- 有序性
```
通常情况下程序执行的顺序按照代码的先后顺序执行，但处理器为了提高程序运行效率，可能会对输入代码进行优化，它不保
证程序中各个语句的执行先后顺序同代码中的顺序一致，但是它会保证程序最终执行结果和代码顺序执行的结果是一致的。
```

## Java 中的这三个概念
- 原子性
```
对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行。 
```
- 可见性
```
当一个共享变量被 volatile 修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值。
```
- 有序性
```
在 Java 中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。
```

## 深入剖析 volatile 关键字
- volatile 关键字的两层语义
    + 保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。
    + 禁止进行指令重排序。
- volatile 不保证原子性
``` 
volatile 对变量的读取和赋值具有原子性，但无法保证自增(读取，加1，写入内存)等类似操作的原子性
```
