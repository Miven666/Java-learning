# 线程池

## 线程池状态

![ThreadPoolStateActive](./ThreadPoolStateActive.png)

- 运行态 `RUNNING`
    + 接受新任务并处理阻塞队列的任务
    + 执行 `shutdown()` 可进入 `SHUTDOWN` 状态
    + 执行 `shutdownNow()` 可进入 `STOP` 状态
- 待关闭状态 `SHUTDOWN`
    + 不接受新任务，但处理阻塞队列的任务
    + 当阻塞队列为空，工作线程数为0时，进入 `TIDYING` 状态
- 停止状态 `STOP`
    + 不接受新任务，也不处理阻塞队列中的任务，并尝试结束执行中的任务
    + 工作线程为0时，进入 `TIDYING` 状态
- 整理状态 `TIDYING`
    + 所有任务执行完毕，也没有工作线程
    + 执行 `terminated()` 进入 `TERMINATED` 状态
- 终止状态 `TERMINATED`
    + 线程池完全终止，并完成所有资源的释放
    
    
## 重要属性
- 线程池状态和工作线程数 `ctl`
    + 高3位表示线程池状态
    + 低29位表示工作线程数
- 核心线程数 `corePoolSize`
    + 线程池中的核心线程数，也可称为可闲置的线程数
- 核心线程是否允许被超时回收 `allowCoreThreadTimeOut`
- 最大线程数 `maximumPoolSize`
    + 线程池最多能够创建的线程数
> 创建线程是有代价的，线程太少，太多显然都是不合适的，最好让线程数随着任务的数量变化而变化。
> 工作线程数可能从0到`maximumPoolSize`之间变化，当执行一段时间之后可能维持在`corePoolSize`，但也不是绝对的，取决于`allowCoreThreadTimeOut`。
- 创建线程的工厂 `threadFactory`
    + 负责创建工作线程
- 缓存任务的阻塞队列 `workQueue`
    + 提高核心线程的利用率，避免重复创建线程造成性能损耗
- 非核心线程存活时间 `keepAliveTime `
    > 回收销毁非核心线程，避免资源浪费
- 拒绝策略 `handler`
    + 触发条件
        + 阻塞队列已满
        + 工作线程数已达最大线程数
    + 策略
        + 抛出异常(默认策略)
        + 直接丢弃该任务
        + 使用调用者线程执行该任务
        + 丢弃任务队列中的最老的一个任务，然后提交该任务
    
## 工作流程
- 提交任务
    > 当向线程池提交一个新的任务时，线程池有三种处理情况，分别是：创建一个工作线程来执行该任务、将任务加入阻塞队列、拒绝该任务。
    1. 当工作线程数小于核心线程数时，直接创建新的核心工作线程
    2. 当工作线程数不小于核心线程数时，就需要尝试将任务添加到阻塞队列中去
    3. 如果能够加入成功，说明队列还没有满，那么需要做以下的二次验证来保证添加进去的任务能够成功被执行
    4. 验证当前线程池的运行状态，如果是非`RUNNING`状态，则需要将任务从阻塞队列中移除，然后拒绝该任务
    5. 验证当前线程池中的工作线程的个数，如果为0，则需要主动添加一个空工作线程来执行刚刚添加到阻塞队列中的任务
    6. 如果加入失败，则说明队列已经满了，那么这时就需要创建新的“临时”工作线程来执行任务
    7. 如果创建成功，则直接执行该任务
    8. 如果创建失败，则说明工作线程数已经等于最大线程数了，则只能拒绝该任务了

- 创建工作线程
    + 不能创建新的线程
        1. 当线程池的状态是`SHUTDOWN`或者`STOP`时
        2. 线程工厂创建线程失败
        3. 当前工作线程的数量不能大于最大线程数
    + 创建新的线程
        1. 尝试通过`CAS`来自增工作线程的个数，如果自增成功了，则会创建新的工作线程，即`Worker`对象
        2. 加锁进行二次验证是否能够创建工作线程，最后如果创建成功，则会启动该工作线程

- 启动工作线程
    > 当工作线程创建成功后，也就是`Worker`对象已经创建好了，这时就需要启动该工作线程，让线程开始干活了，`Worker`对象中关联着一个`Thread`，所以要启动工作线程的话，只要通过`worker.thread.start()`来启动该线程即可。
     启动完了之后，就会执行`Worker`对象的`run`方法，因为`Worker`实现了`Runnable`接口，所以本质上`Worker`也是一个线程。
     通过线程`start`开启之后就会调用到`Runnable`的`run`方法，在`worker`对象的`run`方法中，调用了`runWorker(this)`方法，也就是把当前对象传递给了`runWorker`方法，让他来执行。
- 获取任务并执行
    > `Worker`对象中默认绑定了一个任务，如果该任务不为空的话，那么就是直接执行。
      执行完了之后，就会去阻塞队列中获取任务来执行，而获取任务的过程，需要考虑当前工作线程的个数。
    + 如果工作线程数大于核心线程数，那么就需要通过`poll`来获取，因为这时需要对闲置的线程进行回收
    + 如果工作线程数小于等于核心线程数，那么就可以通过`take`来获取了，因此这时所有的线程都是核心线程，不需要进行回收，前提是没有设置`allowCoreThreadTimeOut`
